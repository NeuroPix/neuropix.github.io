<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width">



<link rel="icon" type="image/ico" href="https://neuropix.github.io//favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://neuropix.github.io//favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://neuropix.github.io//favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://neuropix.github.io//android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://neuropix.github.io//apple-touch-icon.png">

<meta name="description" content=""/>

<title>
    
    Makefile 使用指南 | NeuroPix
    
</title>

<link rel="canonical" href="https://neuropix.github.io/posts/makefile-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>












<link rel="stylesheet" href="/assets/combined.min.a6824bbee0d90d5af09fed9b70395ce7076b615e315037455d903314e96ef91b.css" media="all">









  </head>

  

  
  
  

  <body class="auto">

    <div class="content">
      <header>
        

<div class="header">

    

    <h1 class="header-title">NeuroPix</h1>

    <div class="flex">
        

        
        
      
        <p class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/categories" >
                /categories
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/tags" >
                /tags
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/about" >
                /about
            </a>
        </p>
        
        
    </div>

    

</div>

      </header>

      <main class="main">
        





<div class="breadcrumbs">
    
    <a href="/">Home</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a href="/posts/">Posts</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a class="breadcrumbs-current" href="/posts/makefile-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">Makefile 使用指南</a>
</div>



<div >

  <div class="single-intro-container">

    

    <h1 class="single-title">Makefile 使用指南</h1>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2024-09-27T00:00:00&#43;00:00">September 27, 2024</time>
      

      
    </p>

  </div>

  

  

  

  

  <div class="single-content">
    <h2 id="简介">简介</h2>
<p>在Linux中，<code>make</code>程序用于自动化编译大型源代码。通过运行简单的命令<code>make</code>，我们可以轻松完成编译和安装软件的工作，极大地方便了开发者。</p>
<p><code>make</code>能够自动化完成这些任务，是因为项目中提供了一个名为Makefile的文件。Makefile负责指导<code>make</code>如何编译和链接程序。</p>
<p>Makefile的作用可以类比于Java项目的<code>pom.xml</code>、Node项目的<code>package.json</code>、Rust项目的<code>Cargo.toml</code>。不同之处在于，尽管<code>make</code>最初是为C语言开发的，但实际上它可以用于任何类型的项目，甚至不局限于编程语言。此外，<code>make</code>主要应用于Unix/Linux环境，掌握Makefile的编写可以帮助我们在Linux环境下更好地进行开发，并为后续的Linux内核开发做好准备。</p>
<p>在本教程中，我们将逐步学习如何编写Makefile，内容完全针对零基础的小白用户，只需提前掌握基本的Linux命令使用。</p>
<h2 id="安装make">安装make</h2>
<p>由于<code>make</code>只能在Unix/Linux环境下运行，因此在Windows系统中，我们需要先在Windows下运行Linux。</p>
<p><strong>方法一：</strong> 安装VirtualBox，并下载Linux发行版的安装镜像，推荐使用Ubuntu 22.04，以便在虚拟机中运行Linux。</p>
<p><strong>方法二：</strong> 对于Windows 10/11用户，可以安装WSL（Windows Subsystem for Linux）：</p>
<ol>
<li>安装WSL</li>
<li>在Windows应用商店中搜索并安装Ubuntu 22.04，安装完成后启动，Windows会弹出PowerShell窗口连接到Linux，此时可以输入Linux命令，类似于SSH连接。</li>
</ol>
<p>以Ubuntu为例，在Linux命令行中使用<code>apt</code>命令安装<code>make</code>和GCC工具链：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo apt install build-essential
</span></span></code></pre></div><p>对于macOS系统，由于其内核是BSD（Unix的一种变体），同样可以直接运行<code>make</code>。推荐安装Homebrew，并通过Homebrew安装<code>make</code>和GCC工具链：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ brew install make gcc
</span></span></code></pre></div><p>安装完成后，可以通过输入以下命令验证安装是否成功：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ make -v
</span></span><span style="display:flex;"><span>GNU Make 4.3
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ gcc --version
</span></span><span style="display:flex;"><span>gcc (Ubuntu ...) 11.4.0
</span></span></code></pre></div><p>通过上述步骤，我们成功安装了<code>make</code>和GCC工具链。</p>
<h2 id="makefile基础">Makefile基础</h2>
<p>在Linux环境中，当我们输入<code>make</code>命令时，它会在当前目录查找一个名为Makefile的文件，并根据该文件定义的规则自动执行编译命令等。</p>
<p>Makefile可以理解为“生成文件”的说明书。</p>
<p>举个例子，假设在当前目录下有3个文本文件：<code>a.txt</code>、<code>b.txt</code>和<code>c.txt</code>。我们希望将<code>a.txt</code>与<code>b.txt</code>合并生成中间文件<code>m.txt</code>，再用<code>m.txt</code>与<code>c.txt</code>合并生成最终的目标文件<code>x.txt</code>，整个逻辑如下：</p>
<p>以下是将“文件和依赖”部分转化为有序列表的内容：</p>
<ol>
<li><strong>a.txt</strong>、<strong>b.txt</strong> 和 <strong>c.txt</strong> 是三个独立的文件，作为输入或源文件。</li>
<li><strong>m.txt</strong> 是一个中间文件，依赖于 <strong>a.txt</strong> 和 <strong>b.txt</strong>。这意味着 <strong>m.txt</strong> 的内容可能由这两个文件的数据生成。</li>
<li><strong>x.txt</strong> 是最终文件，依赖于 <strong>m.txt</strong>。这表明 <strong>x.txt</strong> 的内容依赖于中间文件 <strong>m.txt</strong> 的生成。</li>
</ol>
<p>根据上述逻辑，我们编写Makefile。</p>
<h3 id="规则">规则</h3>
<p>Makefile由若干条规则（Rule）构成，每条规则指定一个目标文件（Target）、若干依赖文件（prerequisites）以及生成目标文件的命令。</p>
<p>例如，要生成<code>m.txt</code>，其依赖文件为<code>a.txt</code>与<code>b.txt</code>，规则如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#888;font-style:italic"># 目标文件: 依赖文件1 依赖文件2
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span><span style="color:#666;font-weight:bold;font-style:italic">m.txt</span>: a.txt b.txt
</span></span><span style="display:flex;"><span>	cat a.txt b.txt &gt; m.txt
</span></span></code></pre></div><p>规则的格式为：</p>
<pre tabindex="0"><code>目标文件: 依赖文件1 依赖文件2 ...
</code></pre><p>接下来，命令必须以Tab开头，用于生成目标文件。上述规则使用<code>cat</code>命令合并了<code>a.txt</code>与<code>b.txt</code>，并将结果写入<code>m.txt</code>。生成目标文件的方法不拘一格，命令可以是编译命令，也可以是其他任意命令。</p>
<p>以<code>#</code>开头的行为注释，会被<code>make</code>忽略。</p>
<p>注意：Makefile的规则中，命令必须以Tab开头，不能使用空格。</p>
<p>接下来，生成<code>x.txt</code>的规则如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">x.txt</span>: m.txt c.txt
</span></span><span style="display:flex;"><span>	cat m.txt c.txt &gt; x.txt
</span></span></code></pre></div><p>由于<code>make</code>在执行时默认执行第一条规则，我们将<code>x.txt</code>的规则放在前面。完整的Makefile如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">x.txt</span>: m.txt c.txt
</span></span><span style="display:flex;"><span>	cat m.txt c.txt &gt; x.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">m.txt</span>: a.txt b.txt
</span></span><span style="display:flex;"><span>	cat a.txt b.txt &gt; m.txt
</span></span></code></pre></div><p>在当前目录创建<code>a.txt</code>、<code>b.txt</code>和<code>c.txt</code>并输入一些内容，然后执行<code>make</code>命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ make
</span></span><span style="display:flex;"><span>cat a.txt b.txt &gt; m.txt
</span></span><span style="display:flex;"><span>cat m.txt c.txt &gt; x.txt
</span></span></code></pre></div><p><code>make</code>默认执行第一条规则，创建<code>x.txt</code>，但由于<code>m.txt</code>不存在，必须先执行规则生成<code>m.txt</code>。执行完成后，当前目录下生成了<code>m.txt</code>和<code>x.txt</code>。</p>
<p>可以看出，Makefile定义了一系列规则，在满足依赖条件时执行命令，从而生成目标文件，这就是Makefile的基本概念。</p>
<p>默认执行的规则放在第一条，其他规则的顺序无关紧要，因为<code>make</code>会自动判断依赖关系。</p>
<p>此外，<code>make</code>会打印出执行的每条命令，便于观察执行顺序以便于调试。</p>
<p>如果再次运行<code>make</code>，输出如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ make
</span></span><span style="display:flex;"><span>make: <span style="color:#666;font-style:italic">`</span>x.txt<span style="">&#39;</span> is up to date.
</span></span></code></pre></div><p><code>make</code>检测到<code>x.txt</code>已是最新版本，无需再次执行，因为<code>x.txt</code>的创建时间晚于其依赖的<code>m.txt</code>和<code>c.txt</code>的最后修改时间。</p>
<p><code>make</code>利用文件的创建和修改时间判断是否更新目标文件。当修改<code>c.txt</code>后，再次运行<code>make</code>，则会触发<code>x.txt</code>的更新：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ make
</span></span><span style="display:flex;"><span>cat m.txt c.txt &gt; x.txt
</span></span></code></pre></div><p>但并不会触发<code>m.txt</code>的更新，因为<code>m.txt</code>的依赖<code>a.txt</code>和<code>b.txt</code>未更新。因此，<code>make</code>仅会执行必要的规则，而不会无脑执行所有规则。</p>
<p>在编译大型程序时，全量编译可能需要几十分钟或更长时间。如果仅修改了几个文件，使用Makefile实现增量编译能够大大节省时间。</p>
<p>当然，是否能正确实现增量更新，取决于我们的规则写得是否正确，<code>make</code>本身并不会检查规则逻辑的正确性。</p>
<h3 id="伪目标">伪目标</h3>
<p>由于<code>m.txt</code>与<code>x.txt</code>都是自动生成的文件，因此可以安全地删除它们。</p>
<p>我们希望编写一个<code>clean</code>规则来删除这些文件，而不是手动删除：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">clean</span>:
</span></span><span style="display:flex;"><span>	rm -f m.txt
</span></span><span style="display:flex;"><span>	rm -f x.txt
</span></span></code></pre></div><p><code>clean</code>规则与之前编写的规则不同，它没有依赖文件。因此，要执行<code>clean</code>，必须用命令<code>make clean</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ make clean
</span></span><span style="display:flex;"><span>rm -f m.txt
</span></span><span style="display:flex;"><span>rm -f x.txt
</span></span></code></pre></div><p>但是，如果我们手动创建一个名为<code>clean</code>的文件，这个<code>clean</code>规则就不会执行了！</p>
<p>如果希望<code>make</code>将<code>clean</code>视为伪目标，可以添加一个标识：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">.PHONY</span>: clean
</span></span><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">clean</span>:
</span></span><span style="display:flex;"><span>	rm -f m.txt
</span></span><span style="display:flex;"><span>	rm -f x.txt
</span></span></code></pre></div><p>此时，<code>clean</code>就不再被视为一个文件，而是伪目标（Phony Target）。</p>
<p>大型项目通常会提供<code>clean</code>、<code>install</code>等约定俗成的伪目标名称，以方便用户快速执行特定任务。</p>
<p>一般情况下，除非有人故意创建一个名为<code>clean</code>的文件，否则并不需要用<code>.PHONY</code>标识约定俗成的伪目标名称。</p>
<h3 id="执行多条命令">执行多条命令</h3>
<p>一个规则可以有多条命令，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">cd</span>:
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic">pwd</span>
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic">cd</span> ..
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic">pwd</span>
</span></span></code></pre></div><p>执行<code>cd</code>规则：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ make <span style="font-weight:bold;font-style:italic">cd</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic">pwd</span>
</span></span><span style="display:flex;"><span>/home/ubuntu/makefile-tutorial/v1
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic">cd</span> ..
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic">pwd</span>
</span></span><span style="display:flex;"><span>/home/ubuntu/makefile-tutorial/v1
</span></span></code></pre></div><p>观察输出，可以发现<code>cd ..</code>命令执行后，当前目录没有改变，两次<code>pwd</code>的输出是</p>
<p>相同的。这是因为每条命令都会在一个新的Shell中执行。</p>
<p>为了在同一Shell中执行多条命令，可以用<code>&amp;&amp;</code>连接每条命令，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">cd</span>:
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic">pwd</span> &amp;&amp; <span style="font-weight:bold;font-style:italic">cd</span> .. &amp;&amp; <span style="font-weight:bold;font-style:italic">pwd</span>
</span></span></code></pre></div><p>执行后，第二条<code>pwd</code>将输出上一级目录路径。</p>
<p>另外，若想在多条命令中使用同一个变量，直接写在第一条命令前面的花括号内，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">cd</span>:
</span></span><span style="display:flex;"><span>	{ 
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic">pwd</span>
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic">cd</span> .. 
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic">pwd</span> 
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>但大多数情况下推荐将命令放在同一个规则下，便于阅读和维护。</p>
<h2 id="环境变量">环境变量</h2>
<p>Makefile也支持使用环境变量。我们可以在Shell中执行<code>export</code>命令设置一个变量，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ <span style="font-weight:bold;font-style:italic">export</span> <span style="color:#666;font-weight:bold;font-style:italic">VAR</span>=value
</span></span></code></pre></div><p>然后在Makefile中引用该变量：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">echo</span>:
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic">echo</span> <span style="color:#666;font-weight:bold;font-style:italic">$$</span>VAR
</span></span></code></pre></div><p>注意，在Makefile中引用Shell变量时必须使用两个美元符号<code>$$</code>。执行后将输出<code>value</code>。</p>
<p>同时，Makefile支持定义变量。例如，想要定义一个变量并在规则中使用，可以如下操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">CC</span>=gcc
</span></span><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">CFLAGS</span>=-Wall
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#666;font-weight:bold;font-style:italic">hello</span>: hello.c
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">$(</span>CC<span style="font-weight:bold;text-decoration:underline">)</span> <span style="font-weight:bold;text-decoration:underline">$(</span>CFLAGS<span style="font-weight:bold;text-decoration:underline">)</span> -o hello hello.c
</span></span></code></pre></div><p>这样定义的变量可以在Makefile中多次使用，提高了可维护性。</p>
<h2 id="结语">结语</h2>
<p>本教程简单介绍了Makefile的基本概念、使用方法以及一些常见的规则和变量使用技巧。掌握Makefile的编写能够提高我们在Linux环境中的开发效率，为后续的Linux内核开发奠定基础。希望大家能在实际项目中不断探索和应用Makefile的强大功能！</p>

    
    <script src="https://giscus.app/client.js"
        data-repo="NeuroPix/neuropix.github.io"
        data-repo-id="R_kgDOM3j-IA"
        data-category=""
        data-category-id="DIC_kwDOM3j-IM4Ci1RI"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

    
  </div>

  


  

  
  

<div class="single-pagination">
    <hr />

    <div class="flex">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/posts/%E5%9C%A8-debian-%E4%B8%8A%E5%AE%89%E8%A3%85-openmediavault-%E7%9A%84%E6%8C%87%E5%8D%97/">
                        在 Debian 上安装 OpenMediaVault 的指南
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


      </main>
    </div>

    <footer>
      

    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    



    </footer>
    
  </body>

  <script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>

</html>