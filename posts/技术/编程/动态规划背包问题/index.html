<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width">



<link rel="icon" type="image/ico" href="https://neuropix.github.io//favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://neuropix.github.io//favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://neuropix.github.io//favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://neuropix.github.io//android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://neuropix.github.io//apple-touch-icon.png">

<meta name="description" content=""/>

<title>
    
    动态规划：背包问题 | NeuroPix
    
</title>

<link rel="canonical" href="https://neuropix.github.io/posts/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>












<link rel="stylesheet" href="/assets/combined.min.a6824bbee0d90d5af09fed9b70395ce7076b615e315037455d903314e96ef91b.css" media="all">









  </head>

  

  
  
  

  <body class="auto">

    <div class="content">
      <header>
        

<div class="header" style="position: relative;">

    

    
    <h1 class="header-title">NeuroPix</h1>

    <div class="flex">
         

         
         
            <div class="menu-item" style="position: relative; width: 100px;">  
                <p class="small ">
                    <a href="/" >
                        /home
                    </a>
                </p>

                
            </div>
         
            <div class="menu-item" style="position: relative; width: 100px;">  
                <p class="small ">
                    <a href="/categories/%e6%8a%80%e6%9c%af" >
                        /技术
                    </a>
                </p>

                 
                <div class="submenu" style="display: none; position: absolute; left: 0; top: 100%; background: var(--background); color: var(--content-secondary); border: 1px solid var(--content-se); z-index: 1000; width: 100px;"> 
                     
                    <p class="small ">
                        <a href="/categories/%e6%8a%80%e6%9c%af/%e7%bc%96%e7%a8%8b"  style="color: var(--content-primary);"> 
                            /编程
                        </a>
                    </p>
                     
                    <p class="small ">
                        <a href="/categories/%e6%8a%80%e6%9c%af/%e6%95%b0%e7%a0%81"  style="color: var(--content-primary);"> 
                            /数码
                        </a>
                    </p>
                    
                </div>
                
            </div>
         
            <div class="menu-item" style="position: relative; width: 100px;">  
                <p class="small ">
                    <a href="/categories/%e7%a7%91%e7%a0%94" >
                        /科研
                    </a>
                </p>

                 
                <div class="submenu" style="display: none; position: absolute; left: 0; top: 100%; background: var(--background); color: var(--content-secondary); border: 1px solid var(--content-se); z-index: 1000; width: 100px;"> 
                     
                    <p class="small ">
                        <a href="/categories/%e7%a7%91%e7%a0%94/%e6%95%b0%e5%ad%a6"  style="color: var(--content-primary);"> 
                            /数学
                        </a>
                    </p>
                    
                </div>
                
            </div>
         
            <div class="menu-item" style="position: relative; width: 100px;">  
                <p class="small ">
                    <a href="/categories/%e7%94%9f%e6%b4%bb" >
                        /生活
                    </a>
                </p>

                 
                <div class="submenu" style="display: none; position: absolute; left: 0; top: 100%; background: var(--background); color: var(--content-secondary); border: 1px solid var(--content-se); z-index: 1000; width: 100px;"> 
                     
                    <p class="small ">
                        <a href="/categories/%e7%94%9f%e6%b4%bb/%e6%97%a5%e8%ae%b0"  style="color: var(--content-primary);"> 
                            /日记
                        </a>
                    </p>
                     
                    <p class="small ">
                        <a href="/categories/%e7%94%9f%e6%b4%bb/%e6%91%84%e5%bd%b1"  style="color: var(--content-primary);"> 
                            /摄影
                        </a>
                    </p>
                     
                    <p class="small ">
                        <a href="/categories/%e7%94%9f%e6%b4%bb/%e9%9f%b3%e4%b9%90"  style="color: var(--content-primary);"> 
                            /音乐
                        </a>
                    </p>
                    
                </div>
                
            </div>
         
            <div class="menu-item" style="position: relative; width: 100px;">  
                <p class="small ">
                    <a href="/about" >
                        /about
                    </a>
                </p>

                
            </div>
        
        
    </div>

    

</div>

<script>
    
    document.querySelectorAll('.menu-item').forEach(item => {
        item.addEventListener('mouseenter', () => {
            const submenu = item.querySelector('.submenu'); 
            if (submenu) submenu.style.display = 'block'; 
        });
        item.addEventListener('mouseleave', () => {
            const submenu = item.querySelector('.submenu'); 
            if (submenu) submenu.style.display = 'none'; 
        });
    });
</script>

      </header>

      <main class="main">
        





<div class="breadcrumbs">
    
    <a href="/">Home</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a href="/posts/">Posts</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a class="breadcrumbs-current" href="/posts/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">动态规划：背包问题</a>
</div>



<div >

  <div class="single-intro-container">

    

    <h1 class="single-title">动态规划：背包问题</h1>
    
    <p class="single-summary">背包问题是一种经典的动态规划问题，旨在在给定容量的情况下最大化物品的总价值。以“骨头收藏家”为例，每块骨头具有特定的体积和价值，骨头收藏家需要选择哪些骨头以获得最大的总价值。通过定义递推关系和状态转移方程，我们可以使用递归或动态规划数组来解决这个问题。分为“01背包问题”和“完全背包问题”，前者限制每种物品的数量，后者允许任意数量的物品选择。通过有效地管理和优化状态转移，能够在合理的时间复杂度内计算出最优解。</p>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2020-06-08T00:00:00&#43;00:00">June 8, 2020</time>
      

      
      &nbsp; · &nbsp;
      3 min read
      
    </p>

  </div>

  

  

  
  <aside class="toc">
    <p><strong>Table of contents</strong></p>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#01-背包问题">01 背包问题</a>
      <ul>
        <li><a href="#逆向递推">逆向递推</a></li>
        <li><a href="#正向递推">正向递推</a></li>
        <li><a href="#完全背包问题">完全背包问题</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>
  

  

  <div class="single-content">
    <p>今天来简单聊聊动态规划中典型的背包问题。</p>
<h2 id="01-背包问题">01 背包问题</h2>
<p>先来看看下面这样一道题目吧。</p>
<p><strong>Problem Description:</strong> Many years ago, in Teddy’s hometown there was a man who was called “Bone Collector”. This man liked to collect various bones, such as dog’s, cow’s, and he also went to the grave. The bone collector had a big bag with a volume of V, and along his trip of collecting, there are a lot of bones. Obviously, different bones have different values and different volumes. Now given each bone’s value along his trip, can you calculate out the maximum total value the bone collector can get?</p>
<p>题目的意思大概是这样的：有一位“骨头收藏家”喜欢收集骨头，每一块骨头的体积 w[i] 和价值 v[i] 都已知，而他装骨头的袋子容量只有 V，计算他能够获得骨头的最大价值。</p>
<p>“背包问题”获取最大利益，乍一看确实是贪心算法，但这也是一道典型的动态规划问题。动态规划是算法设计方法之一，是用来求得最优解的数学方法。</p>
<p>假设我们使用一个函数 <code>rec(i,j)</code> 来表示“从第 i 块骨头开始拿重量不超过 j 的最大收益”，那么对于第 i 块骨头，有如下几种情况。</p>
<p>剩余空间 j 小于第 i 块骨头的体积，无法拿这一块骨头，那么对于从第 i+1 块骨头开始拿获得的最大收益有 <code>rec(i,j)=rec(i+1,j)</code>。</p>
<p>可以拿得下这一块骨头，选择拿或者不拿。若拿，则对于从第 i+1 块骨头开始拿获得的最大收益有 <code>rec(i,j)=rec(i+1,j-w[i])+v[i]</code>；若不拿，则与拿不下相同 <code>rec(i,j)=rec(i+1,j)</code>。而我们要选择这两者中较大的一个才算最大收益。</p>
<p>这样我们便得到了函数的递推关系，这种递推关系被称为“状态转移方程”，使用代码表示则为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">rec</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i, <span style="font-weight:bold;text-decoration:underline">int</span> j) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> res;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (i == N)
</span></span><span style="display:flex;"><span>        res = 0;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">else</span> <span style="font-weight:bold;text-decoration:underline">if</span> (j &lt; w[i])
</span></span><span style="display:flex;"><span>        res = rec(i + 1, j);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">else</span>
</span></span><span style="display:flex;"><span>        res = max(rec(i + 1, j), rec(i + 1, j - w[i]) + v[i]);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是这样会产生很多重复的函数调用，特别是当 N 比较大的时候，程序运行时间会以指数形式增长。所以我们可以使用一个动态规划数组将计算过的函数值保存起来，当需要调用的时候可以直接从数组中访问。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> DP[1000][1000];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">rec</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i, <span style="font-weight:bold;text-decoration:underline">int</span> j) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (DP[i][j] != -1) { <span style="color:#888;font-style:italic">// 判断是否存在数据
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>        <span style="font-weight:bold;text-decoration:underline">return</span> DP[i][j];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> res;
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">return</span> DP[i][j] = res; <span style="color:#888;font-style:italic">// 将值记录在数组中
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>    memset(DP, -1, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(DP)); <span style="color:#888;font-style:italic">// 初始化数组
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>}
</span></span></code></pre></div><p>首先在主函数中使用 <code>memset</code> 函数将数组初始化为 -1，为了和保存的元素做区别。函数在返回计算值的同时将值保存在数组中。</p>
<h3 id="逆向递推">逆向递推</h3>
<p>既然对于每一种情况的最优解都保存在了数组中，那在进行动态规划的时候，我们可以直接初始化数组。数组初始化的方法就是利用得到的状态转移方程，即递推关系，之后可以重复利用动态规划的结果，省去了多余的函数调用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> DP[1000][1000];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = N - 1; i &gt;= 0; i--) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = 0; j &lt;= V; j++) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold;text-decoration:underline">if</span> (j &lt; w[i])
</span></span><span style="display:flex;"><span>                DP[i][j] = DP[i + 1][j];
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold;text-decoration:underline">else</span>
</span></span><span style="display:flex;"><span>                DP[i][j] = max(DP[i + 1][j], DP[i + 1][j - w[i]] + v[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="正向递推">正向递推</h3>
<p>上面的递推关系是逆向的，从最后一块骨头递推到第一块，即 i 从 N-1 到 0。我们也可以从正向递推，这时的 <code>DP[i+1][j]</code> 被定义为“从前 i 块骨头中选取体积不超过 j 所获取的最大收益”，递推关系写成代码如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> DP[1000][1000];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; i &lt; N; i++) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = 0; j &lt;= V; j++) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold;text-decoration:underline">if</span> (j &lt; w[i])
</span></span><span style="display:flex;"><span>                DP[i + 1][j] = DP[i][j];
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold;text-decoration:underline">else</span>
</span></span><span style="display:flex;"><span>                DP[i + 1][j] = max(DP[i][j], DP[i][j - w[i]] + v[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此外，除了运用递推方式逐项求解之外，还可以把状态转移想象成从“前 i 个物品中选取总重不超过 j 时的状态”向“前 i+1 个物品中选取总重不超过 j”和“前 i+1 个物品中选取总重不超过 j+w[i] 时的状态”的转移，于是可以实现成如下形式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> DP[1000][1000];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; i &lt; N; i++) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = 0; j &lt;= V; j++) {
</span></span><span style="display:flex;"><span>            DP[i + 1][j] = max(DP[i + 1][j], DP[i][j]);
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold;text-decoration:underline">if</span> (j + w[i] &lt;= V)
</span></span><span style="display:flex;"><span>                DP[i + 1][j + w[i]] = max(DP[i + 1][j + w[i]], DP[i][j] + v[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="完全背包问题">完全背包问题</h3>
<p>上文所提到的可选择的物品个数有限的背包问题称为“01 背包问题”，假如可选择的每一种物品数量不限，则被称为“完全背包问题”。</p>
<p>若将上文题目改为每种骨头可以选择任意多的数量，就变成了一道完全背包问题。</p>
<p>我们还是设 <code>DP[i+1][j]</code> 表示“从前 i 块骨头中选取体积不超过 j 所获取的最大收益”，假设对于第 i 种骨头选了 k 块，而要选择其中收益最高的方法，则有：<code>DP[i+1][j]=max{DP[i][j-k*w[i]]+k*v[i]|k&gt;=0}</code>，使用代码表示如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> DP[1000][1000];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; i &lt; N; i++) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = 0; j &lt;= V; j++) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> k = 0; k * w[i] &lt;= j; k++) {
</span></span><span style="display:flex;"><span>                DP[i + 1][j] = max(DP[i][j - k * w[i]] + k * v[i], DP[i + 1][j]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样多加了一层循环，使得算法的复杂度再次提升。不难发现，在 <code>DP[i+1][j]</code> 中选择 k (k&gt;=1) 个与在 <code>DP[i+1][j-w[i]]</code> 中选择 k-1 个，计算出来的结果相同。所以选择 k (k&gt;=1) 个的部分在之前的计算中已经得出过，那么可以简化状态转移方程。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>DP[i+1][j]=max{DP[i][j-k*w[i]]+k*v[i]|k&gt;=0}
</span></span><span style="display:flex;"><span>          =max(DP[i][j],max{DP[i][j-k*w[i]]+k*v[i]|k&gt;=1})
</span></span><span style="display:flex;"><span>          =max(DP[i][j],max{DP[i][j-k*w[i]-w[i]]+k*v[i]+v[i]|k&gt;=0})
</span></span><span style="display:flex;"><span>          =max(DP[i][j],DP[i+1][j-w[i]]+v[i])
</span></span></code></pre></div><p>而如上状态转移方程使用代码表示便为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> DP[1000][1000];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; i &lt; N; i++) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = 0; j &lt;= V; j++) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold;text-decoration:underline">if</span> (j &lt; w[i])
</span></span><span style="display:flex;"><span>                DP[i + 1][j] = DP[i][j];
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold;text-decoration:underline">else</span>
</span></span><span style="display:flex;"><span>                DP[i + 1][j] = max(DP[i][j], DP[i + 1][j - w[i]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> + v[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="小结">小结</h3>

    
    <script src="https://giscus.app/client.js"
        data-repo="NeuroPix/neuropix.github.io"
        data-repo-id="R_kgDOM3j-IA"
        data-category=""
        data-category-id="DIC_kwDOM3j-IM4Ci1RI"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

    
  </div>

  


  

  
  

<div class="single-pagination">
    <hr />

    <div class="flex">

        <div class="single-pagination-prev">
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/posts/%E6%8A%80%E6%9C%AF/%E5%B0%86-hexo-%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">
                        将 Hexo 博客部署到云服务器
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


      </main>
    </div>

    <footer>
      

    
    
    
    <p>© 2024 NeuroPix. All rights reserved.</p>
    



<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>

    </footer>
    
  </body>

  <script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>

</html>